FIXME: cval is an imcomplete type. It must be, "cval int" ex.

Il n'y a pas de liste de fonctions. Juste une liste de variables. Une fonction
est juste une variable de type comme un autre, mais de type fonction.

TODO:

Operator Priority list:
= 10
int 9
/ 6
* 6
- 5
+ 5

printf "Hello world!"
int x = #2 + 2 // The type #2 + 2 is infered by the type of the variable.

Idealement, fuck off le #...bullshit...# Les fonctions C de bases serait simplement des fonctions C,
parce que en QC, tu peux caller des fonctions C, c'est le but...

(int x) = (2 + 4)

cval x
x = #1 + 2;#

int x
x
$vars
x := 2
x := 4 + 3
=> 7
int x := 2
int y := x + 3

---

Rajouter une syntax pour que le contenu soit du C inchanger.

Un lambda est un block. La seule forme est: Ce qui est pratique quand pas args.
{|x y| return x + y}
{printf "Hello world!"}

---

Fonctions de base: Est-ce que c'est des fonctions comme les autres. PAS DE MOTS (ex: if)!!!
::
... ? ... !? ...
x : []
x == 1 ? true ?! false

P-e qu'au lieu de x:[], utiliser x,[]

Les operateurs ont des priorites. :: est un operateur. -> aussi. p(->) > p(::)

-> est un op qui donne un type

a -> b -> c == a -> (b -> c)

-> :: Type -> Type // Marche pas. Definit par lui meme

A source file is a script. The :: fonction defines functions, the assignment defines variables.
The main function compiles the given function. Ex. T'as un application qui roule dans la fonction
run. Tu fais: main run.

Creer une librarie SDL-ncurses. Implementer ncurses en SDL. P-e utiliser les memes
noms de fonctions, ainsi juste changer l'include et le linkage pour que ca marche.

C'est plus rapide pour développer parce que c'est real time.
C'est plus facile débugger parce que tu peux caller des fonctions.
Tu fais moins d'erreur: Le ; est mis automatiquement ex. (Tu peux pas mettre de ; a la fin d'un if par ex par erreur.)

Plus tard, pour eviter de reloader l'application au complet,
pour que ce soit real time, avoir une application dans une autre.
L'application parent gererait tout ce qui est statique et ne change pas,
l'application enfant reloaderait tout ce qui peut changer comme les fonctions.
La premiere app est l'editeur. La seconde est le proglang.

Quand tu fais enter, le ; est rajouter.
Pour commencer l'intérieur ({), faire shift+enter.
Pour finir l'intérieur (}), faire ctrl+enter.

>> def add int int int
Plus tard:
>> def add :: int -> int -> int
--
>> edit add
\x y -> return x + y;

Toutes les fonctions sont ecrites sous formes de lambda.
Pour l'instant, meme les fonctions sans args...

main = \ ->

Ajouter une petite db interne pour pouvoir rechercher les fonctions par noms et par types.

>> gen Arg val:char[52] nxt:Arg*
=> model/Arg.h 
=> model/Arg.c
=> update app.h
=> update compile.sh

p-e que def est une macro, tout comme :: en serait une. if et else pourrait aussi.

alias est typedef

Quand je liste, mettre un chiffre comme ca je peux referencer par le chiffre au lieu de tout recrire. Ou $+lettre

Version 0.1
>> def add, int x, int y, int  // Plus tard: add :: int x -> int y -> int
>> edit add
int add(int x, int y) {
  return x + y;
} //(ctrl+enter) => ;}
>> restart
>> add 1, 3  // Tu peux
=> 4

// Currying!!!

>> def main, int argc, char* argv[], int
=> cat "int main(int argc, char* argv[])" > def.h // TODO: Vérifier si main est déjà définie.

>> def run, void

>> edit main
.. run()

>> list
=> main, int argc, char* argv[], int
=> run, void

>> show main
.. run()

>> run main

main.o
main.c

Etre capable de debugger. Inspect var.
